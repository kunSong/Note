## Sort I

### 为什么插入排序比冒泡排序更受欢迎？

+ 插入排序和冒泡排序的时间复杂度相同，都是 O(n)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？

### 排序算法的执行效率

+ 最好、最坏、平均情况时间复杂度

    + 说出对应原始数据的有序度不同，对排序时间是有影响的

+ 时间复杂度系数、常数、低阶

    + 对于排序算法，数据规模不会很大，可能是10，100，1000，所以系数、常数和低阶都需要考虑进去

+ 基于比较的排序算法，比较次数和交换（或移动）次数也要考虑进去

### 排序算法的内存消耗

+ 原地排序：特指空间复杂度为O(1)，也就是并没有利用新空间

### 排序算法的稳定性

+ 稳定的排序算法：同样的值在排序前后顺序没有改变

    + 例子：电商交易平台中的订单，需要按金额从小到大排序并且下单时间从早到晚排序。
    + 方法：先按时间进行排序，利用稳定排序算法按金额排序。这样可以保证按时间排序完以后，金额相同的订单前后顺序保持不变。

![11_1]](https://github.com/kunSong/Note/blob/master/ARTS/Algorithms/res/10_1.jpg)

### 冒泡排序

+ 代码逻辑
    将最大的数比较并冒泡到最顶部，第一个循环控制趟数，第二个循环控制还剩余需要冒泡的数，注意控制条件`j < n - i - 1`

+ 时间复杂度
    + 等差数列求和通项公式 `sn = a1n + n(n-1) / 2 * d`
    + 等差数列单项通项公式 `an = a1n + (n-1)d`
    + 满有序度为差为1的数列求和 `n(n+1) / 2`
    + 逆序度为满有序度 - 有序度
    + 最好时间复杂度 `O(n)` 已经有序仅遍历一次
    + 最坏时间复杂度 `O(n2)`
    + 平均时间复杂度 `(n + 1) n / 4` `O(n2)`

### 插入排序

+ 代码逻辑
    已排序区间为第一个元素，从为排序区间中找数往以排序区间中进行比较找到合适位置就插入，在比较过程中设计到数据移动所以要把需要插入的值保存一下`value = a[i]` `j=i-1;j>=0;j--` `a[j+1] = a[j]` 第一个循环控制取要插入的值，第二个循环控制已排序区间的比较

### 三种排序算法比较

比较 | 原地排序 | 稳定排序 | 最好 | 最坏 | 平均
-|-|-|-|-|-
冒泡排序 | yes | yes | O(n) | O(n2) | O(n2)
插入排序 | yes | yes | O(n) | O(n2) | O(n2)
选择排序 | yes | no  | O(n2) | O(n2) | O(n2)

### 开篇问题

+ 冒泡排序算法比插入排序多了3行比较代码，在时间效率上比插入排序慢，对于极致效率来说。但是这两种排序算法比较适合小规模数据

### 思考

+ 是否可以用链表来实现这三种算法?
    前提条件链表节点的值是否可以变，如果不能变，实现比较复杂，但是时间复杂度上无变化

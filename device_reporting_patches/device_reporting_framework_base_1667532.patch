From 61aeef734c6b69eb3358772d0ad4aadc94bfcb1d Mon Sep 17 00:00:00 2001
From: Fang Yunong <yunong@codeaurora.org>
Date: Thu, 4 Aug 2016 18:33:57 +0800
Subject: [PATCH] Frameworks: Add device reporting function

1. Add device reporting permission
2. Add check app status intent
3. Add check location status intent

Change-Id: I6be3af26cc007eb850fcfd60cd343d9a0faeee9f
CRs-Fixed: 1039338
---
 core/java/android/net/LinkProperties.java          |   7 +
 core/res/AndroidManifest.xml                       |  29 ++
 .../android/server/am/ActivityManagerService.java  | 113 ++++--
 .../java/com/android/server/am/ActivityStack.java  |   9 +
 .../core/java/com/android/server/am/AppErrors.java |  29 +-
 .../com/android/server/am/AppStateBroadcaster.java | 383 +++++++++++++++++++++
 .../java/com/android/server/am/UserController.java |   2 +-
 7 files changed, 547 insertions(+), 25 deletions(-)
 create mode 100644 services/core/java/com/android/server/am/AppStateBroadcaster.java

diff --git a/core/java/android/net/LinkProperties.java b/core/java/android/net/LinkProperties.java
index 1bb0fbb..368cb1c 100644
--- a/core/java/android/net/LinkProperties.java
+++ b/core/java/android/net/LinkProperties.java
@@ -377,6 +377,13 @@ public final class LinkProperties implements Parcelable {
     }
 
     /**
+     * @hide
+     */
+    public Collection<InetAddress> getDnses() {
+        return Collections.unmodifiableCollection(mDnses);
+    }
+
+    /**
      * Sets the DNS domain search path used on this link.
      *
      * @param domains A {@link String} listing in priority order the comma separated
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 310e46a..a5e391f 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -503,6 +503,10 @@
     <protected-broadcast android:name="android.telecom.action.TTY_PREFERRED_MODE_CHANGED" />
     <protected-broadcast android:name="android.telecom.action.CURRENT_TTY_MODE_CHANGED" />
 
+    <protected-broadcast android:name="diagandroid.data.receivePDPContextState" />
+    <protected-broadcast android:name="diagandroid.phone.receiveDetailedCallState" />
+    <protected-broadcast android:name="diagandroid.app.receiveDetailedApplicationState" />
+    <protected-broadcast android:name="com.tmobile.comm.RECEIVE_METRICS" />
     <!-- ====================================================================== -->
     <!--                          RUNTIME PERMISSIONS                           -->
     <!-- ====================================================================== -->
@@ -513,6 +517,31 @@
     <!-- ====================================================================== -->
     <eat-comment />
 
+    <!-- Allows an application to receive diagandroid.app.ApplicationState intents
+        @hide
+    -->
+    <permission android:name="diagandroid.app.receiveDetailedApplicationState"
+        android:label="receive information about application execution status"
+        android:protectionLevel="signatureOrSystem" />
+
+    <!-- Allows an application to receive diagandroid.app.ApplicationState intents
+        @hide
+    -->
+    <permission android:name="diagandroid.phone.receiveDetailedCallState"
+        android:label="receive information about voice call status"
+        android:protectionLevel="signatureOrSystem" />
+
+    <!-- Allows an application receive PDP Context state intents.
+        @hide
+    -->
+    <permission android:name="diagandroid.data.receivePDPContextState"
+        android:label="receive PDP Context State intents"
+        android:protectionLevel="signatureOrSystem" />
+
+    <permission android:name="com.tmobile.comm.RECEIVE_METRICS"
+        android:label="receive wifi state intents"
+        android:protectionLevel="signatureOrSystem" />
+
     <!-- Used for runtime permissions related to contacts and profiles on this
         device. -->
     <permission-group android:name="android.permission-group.CONTACTS"
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index f968bac..c30b823 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -200,6 +200,7 @@ import android.service.voice.IVoiceInteractionSession;
 import android.service.voice.VoiceInteractionManagerInternal;
 import android.service.voice.VoiceInteractionSession;
 import android.telecom.TelecomManager;
+import android.telephony.TelephonyManager;
 import android.text.format.DateUtils;
 import android.text.format.Time;
 import android.text.style.SuggestionSpan;
@@ -536,6 +537,9 @@ public final class ActivityManagerService extends ActivityManagerNative
     private static final String ACTION_POWER_OFF_ALARM =
             "org.codeaurora.alarm.action.POWER_OFF_ALARM";
 
+    private final static String ACTION_SIM_STATE_CHANGED =
+            "android.intent.action.SIM_STATE_CHANGED";
+
     // Delay to disable app launch boost
     static final int APP_BOOST_MESSAGE_DELAY = 3000;
     // Lower delay than APP_BOOST_MESSAGE_DELAY to disable the boost
@@ -1899,7 +1903,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                     String pkg = bundle.getString("pkg");
                     String reason = bundle.getString("reason");
                     forceStopPackageLocked(pkg, appId, false, false, true, false,
-                            false, userId, reason);
+                            false, userId, reason,
+                            AppStateBroadcaster.STOP_REASON_USER_HALT);
                 }
             } break;
             case FINALIZE_PENDING_INTENT_MSG: {
@@ -3844,6 +3849,11 @@ public final class ActivityManagerService extends ActivityManagerNative
                     app.processName, hostingType,
                     hostingNameStr != null ? hostingNameStr : "");
 
+            if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+                AppStateBroadcaster.sendApplicationStart(mContext,app.info.packageName,
+                        startResult.pid);
+            }
+
             try {
                 AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid,
                         app.info.seinfo, app.info.sourceDir, startResult.pid);
@@ -3944,7 +3954,8 @@ public final class ActivityManagerService extends ActivityManagerNative
             // the package was initially frozen through KILL_APPLICATION_MSG, so
             // it doesn't hurt to use it again.)
             forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,
-                    false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
+                    false, true, false, false, UserHandle.getUserId(app.userId), "start failure",
+                    AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
         }
     }
 
@@ -5297,6 +5308,10 @@ public final class ActivityManagerService extends ActivityManagerNative
                 }
                 Slog.i(TAG, "Process " + app.processName + " (pid " + pid
                         + ") has died");
+                if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+                    AppStateBroadcaster.sendApplicationStop(mContext,app.info.packageName,app.pid,
+                            AppStateBroadcaster.STOP_REASON_CRASH);
+                }
                 mAllowLowerMemLevel = true;
                 if (mEnableNetOpts) {
                     networkOptsCheck(1, app.processName);
@@ -5304,6 +5319,10 @@ public final class ActivityManagerService extends ActivityManagerNative
             } else {
                 // Note that we always want to do oom adj to update our state with the
                 // new number of procs.
+                if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+                    AppStateBroadcaster.sendApplicationStop(mContext,app.info.packageName,app.pid,
+                            AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
+                }
                 mAllowLowerMemLevel = false;
                 doLowMem = false;
             }
@@ -5590,7 +5609,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                         android.Manifest.permission.CLEAR_APP_USER_DATA,
                         pid, uid, -1, true)
                         == PackageManager.PERMISSION_GRANTED) {
-                    forceStopPackageLocked(packageName, pkgUid, "clear data");
+                    forceStopPackageLocked(packageName, pkgUid, "clear data",
+                            AppStateBroadcaster.STOP_REASON_USER_HALT);
                 } else {
                     throw new SecurityException("PID " + pid + " does not have permission "
                             + android.Manifest.permission.CLEAR_APP_USER_DATA + " to clear data"
@@ -5684,7 +5704,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                     return;
                 }
                 killPackageProcessesLocked(packageName, appId, userId,
-                        ProcessList.SERVICE_ADJ, false, true, true, false, "kill background");
+                        ProcessList.SERVICE_ADJ, false, true, true, false, "kill background",
+                        AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
             }
         } finally {
             Binder.restoreCallingIdentity(callingId);
@@ -5727,7 +5748,14 @@ public final class ActivityManagerService extends ActivityManagerNative
 
                 final int N = procs.size();
                 for (int i = 0; i < N; i++) {
-                    removeProcessLocked(procs.get(i), false, true, "kill all background");
+                    if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)) {
+                        ProcessRecord proc = procs.get(i);
+                        AppStateBroadcaster.sendApplicationStop(mContext, proc.info.packageName,
+                                proc.pid, AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
+                        removeProcessLocked(proc, false, true, "kill all background");
+                    } else {
+                        removeProcessLocked(procs.get(i), false, true, "kill all background");
+                    }
                 }
 
                 mAllowLowerMemLevel = true;
@@ -5828,7 +5856,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                                 + packageName + ": " + e);
                     }
                     if (mUserController.isUserRunningLocked(user, 0)) {
-                        forceStopPackageLocked(packageName, pkgUid, "from pid " + callingPid);
+                        forceStopPackageLocked(packageName, pkgUid, "from pid " + callingPid,
+                                AppStateBroadcaster.STOP_REASON_USER_HALT);
                         finishForceStopPackageLocked(packageName, pkgUid);
                     }
                 }
@@ -6018,9 +6047,10 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
     }
 
-    private void forceStopPackageLocked(final String packageName, int uid, String reason) {
+    private void forceStopPackageLocked(final String packageName, int uid, String reason,
+            int stopReason) {
         forceStopPackageLocked(packageName, UserHandle.getAppId(uid), false,
-                false, true, false, false, UserHandle.getUserId(uid), reason);
+                false, true, false, false, UserHandle.getUserId(uid), reason, stopReason);
     }
 
     private void finishForceStopPackageLocked(final String packageName, int uid) {
@@ -6040,7 +6070,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     private final boolean killPackageProcessesLocked(String packageName, int appId,
             int userId, int minOomAdj, boolean callerWillRestart, boolean allowRestart,
-            boolean doit, boolean evenPersistent, String reason) {
+            boolean doit, boolean evenPersistent, String reason, int stopReason) {
         ArrayList<ProcessRecord> procs = new ArrayList<>();
 
         // Remove all processes this package may have touched: all with the
@@ -6105,7 +6135,12 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         int N = procs.size();
         for (int i=0; i<N; i++) {
-            removeProcessLocked(procs.get(i), callerWillRestart, allowRestart, reason);
+            if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)) {
+                ProcessRecord proc = procs.get(i);
+                AppStateBroadcaster.sendApplicationStop(mContext,proc.info.packageName,proc.pid,
+                        stopReason);
+                removeProcessLocked(proc, callerWillRestart, allowRestart, reason);
+            }
         }
         updateOomAdjLocked();
         return N > 0;
@@ -6211,7 +6246,8 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     final boolean forceStopPackageLocked(String packageName, int appId,
             boolean callerWillRestart, boolean purgeCache, boolean doit,
-            boolean evenPersistent, boolean uninstalling, int userId, String reason) {
+            boolean evenPersistent, boolean uninstalling, int userId, String reason,
+            int stopReason) {
         int i;
 
         if (userId == UserHandle.USER_ALL && packageName == null) {
@@ -6239,7 +6275,8 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         boolean didSomething = killPackageProcessesLocked(packageName, appId, userId,
                 ProcessList.INVALID_ADJ, callerWillRestart, true, doit, evenPersistent,
-                packageName == null ? ("stop user " + userId) : ("stop " + packageName));
+                packageName == null ? ("stop user " + userId) : ("stop " + packageName),
+                stopReason);
 
         if (mStackSupervisor.finishDisabledPackageActivitiesLocked(
                 packageName, null, doit, evenPersistent, userId)) {
@@ -6483,6 +6520,10 @@ public final class ActivityManagerService extends ActivityManagerNative
             cleanupAppInLaunchingProvidersLocked(app, true);
             // Take care of any services that are waiting for the process.
             mServices.processStartTimedOutLocked(app);
+            if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+                AppStateBroadcaster.sendApplicationStop(mContext, app.info.packageName, app.pid,
+                        AppStateBroadcaster.STOP_REASON_ANR);
+            }
             app.kill("start timeout", true);
             removeLruProcessLocked(app);
             if (mBackupTarget != null && mBackupTarget.app.pid == pid) {
@@ -6870,7 +6911,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                     for (String pkg : pkgs) {
                         synchronized (ActivityManagerService.this) {
                             if (forceStopPackageLocked(pkg, -1, false, false, false, false, false,
-                                    0, "query restart")) {
+                                    0, "query restart",
+                                    AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT)) {
                                 setResultCode(Activity.RESULT_OK);
                                 return;
                             }
@@ -6957,6 +6999,19 @@ public final class ActivityManagerService extends ActivityManagerNative
                         });
                 scheduleStartProfilesLocked();
             }
+
+            IntentFilter simInfoFilter = new IntentFilter();
+            simInfoFilter.addAction(ACTION_SIM_STATE_CHANGED);
+            mContext.registerReceiver(new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context context, Intent intent) {
+                    if ((SystemProperties.get("gsm.sim.operator.numeric")
+                            .equals(AppStateBroadcaster.KEY_DEVICE_REPORTING_REGIONAL)) &&
+                            !AppStateBroadcaster.getEnableIntentBroadcast()){
+                        AppStateBroadcaster.enableIntentBroadcast(mContext, mProcessNames);
+                    }
+                }
+            }, simInfoFilter);
         }
     }
 
@@ -11824,6 +11879,8 @@ public final class ActivityManagerService extends ActivityManagerNative
             timedout = mStackSupervisor.shutdownLocked(timeout);
         }
 
+        if (AppStateBroadcaster.isDeviceReportingEnabled(mContext))
+            AppStateBroadcaster.disableIntentBroadcast();
         mAppOpsService.shutdown();
         if (mUsageStatsService != null) {
             mUsageStatsService.prepareShutdown();
@@ -12046,7 +12103,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                 mDebugTransient = !persistent;
                 if (packageName != null) {
                     forceStopPackageLocked(packageName, -1, false, false, true, true,
-                            false, UserHandle.USER_ALL, "set debug app");
+                            false, UserHandle.USER_ALL, "set debug app",
+                            AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
                 }
             }
         } finally {
@@ -12890,7 +12948,8 @@ public final class ActivityManagerService extends ActivityManagerNative
             try {
                 killPackageProcessesLocked(null, appId, userId,
                         ProcessList.PERSISTENT_PROC_ADJ, false, true, true, true,
-                        reason != null ? reason : "kill uid");
+                        reason != null ? reason : "kill uid",
+                        AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
             } finally {
                 Binder.restoreCallingIdentity(identity);
             }
@@ -13214,6 +13273,10 @@ public final class ActivityManagerService extends ActivityManagerNative
                 for (int i=procsToKill.size()-1; i>=0; i--) {
                     ProcessRecord proc = procsToKill.get(i);
                     Slog.i(TAG, "Removing system update proc: " + proc);
+                    if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+                        AppStateBroadcaster.sendApplicationStop(mContext, proc.info.packageName,
+                                proc.pid, AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
+                    }
                     removeProcessLocked(proc, true, false, "system update done");
                 }
             }
@@ -17941,7 +18004,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                             if (list != null && list.length > 0) {
                                 for (int i = 0; i < list.length; i++) {
                                     forceStopPackageLocked(list[i], -1, false, true, true,
-                                            false, false, userId, "storage unmount");
+                                            false, false, userId, "storage unmount",
+                                            AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
                                 }
                                 mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                                 sendPackageBroadcastLocked(
@@ -17968,7 +18032,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                                         forceStopPackageLocked(ssp, UserHandle.getAppId(
                                                 intent.getIntExtra(Intent.EXTRA_UID, -1)),
                                                 false, true, true, false, fullUninstall, userId,
-                                                removed ? "pkg removed" : "pkg changed");
+                                                removed ? "pkg removed" : "pkg changed",
+                                                AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
                                     }
                                     final int cmd = killProcess
                                             ? IApplicationThread.PACKAGE_REMOVED
@@ -17998,7 +18063,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                                         killPackageProcessesLocked(ssp, UserHandle.getAppId(
                                                 intent.getIntExtra(Intent.EXTRA_UID, -1)),
                                                 userId, ProcessList.INVALID_ADJ,
-                                                false, true, true, false, "change " + ssp);
+                                                false, true, true, false, "change " + ssp,
+                                                AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
                                     }
                                     cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess,
                                             intent.getStringArrayExtra(
@@ -18590,7 +18656,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             final long origId = Binder.clearCallingIdentity();
             // Instrumentation can kill and relaunch even persistent processes
             forceStopPackageLocked(ii.targetPackage, -1, true, false, true, true, false, userId,
-                    "start instr");
+                    "start instr", AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
             ProcessRecord app = addAppLocked(ai, false, abiOverride);
             app.instrumentationClass = className;
             app.instrumentationInfo = ai;
@@ -18645,7 +18711,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         app.instrumentationArguments = null;
 
         forceStopPackageLocked(app.info.packageName, -1, false, false, true, true, false, app.userId,
-                "finished inst");
+                "finished inst", AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
     }
 
     public void finishInstrumentation(IApplicationThread target,
@@ -21216,6 +21282,10 @@ public final class ActivityManagerService extends ActivityManagerNative
                         + (app.thread != null ? app.thread.asBinder() : null)
                         + ")\n");
                     if (app.pid > 0 && app.pid != MY_PID) {
+                        if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+                            AppStateBroadcaster.sendApplicationStop(mContext, app.info.packageName,
+                                    app.pid, AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
+                        }
                         app.kill("empty", false);
                     } else {
                         try {
@@ -22065,7 +22135,8 @@ public final class ActivityManagerService extends ActivityManagerNative
             synchronized(this) {
                 killPackageProcessesLocked(packageName, UserHandle.getAppId(pkgUid), userId,
                         ProcessList.FOREGROUND_APP_ADJ, false, true, true, false,
-                        "dep: " + packageName);
+                        "dep: " + packageName,
+                        AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
             }
         } finally {
             Binder.restoreCallingIdentity(callingId);
diff --git a/services/core/java/com/android/server/am/ActivityStack.java b/services/core/java/com/android/server/am/ActivityStack.java
index 58290e7..5e316b4 100644
--- a/services/core/java/com/android/server/am/ActivityStack.java
+++ b/services/core/java/com/android/server/am/ActivityStack.java
@@ -75,6 +75,7 @@ import static com.android.server.am.ActivityRecord.STARTING_WINDOW_SHOWN;
 import static com.android.server.am.ActivityStackSupervisor.FindTaskResult;
 import static com.android.server.am.ActivityStackSupervisor.ON_TOP;
 import static com.android.server.am.ActivityStackSupervisor.PRESERVE_WINDOWS;
+import com.android.server.am.AppStateBroadcaster;
 import static com.android.server.wm.AppTransition.TRANSIT_ACTIVITY_CLOSE;
 import static com.android.server.wm.AppTransition.TRANSIT_ACTIVITY_OPEN;
 import static com.android.server.wm.AppTransition.TRANSIT_NONE;
@@ -1146,6 +1147,10 @@ final class ActivityStack {
                 mService.updateUsageStats(prev, false);
                 prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,
                         userLeaving, prev.configChangeFlags, dontWait);
+                if (AppStateBroadcaster.isDeviceReportingEnabled(mService.mContext)) {
+                    AppStateBroadcaster.
+                            sendApplicationFocusLoss(mService.mContext, prev.packageName);
+                }
             } catch (Exception e) {
                 // Ignore exception, if process died other code will cleanup.
                 Slog.w(TAG, "Exception thrown during pause", e);
@@ -1429,6 +1434,10 @@ final class ActivityStack {
 
         mStackSupervisor.reportResumedActivityLocked(next);
 
+        if (AppStateBroadcaster.isDeviceReportingEnabled(mService.mContext)) {
+            AppStateBroadcaster.
+                    sendApplicationFocusGain(mService.mContext, next.packageName);
+        }
         next.resumeKeyDispatchingLocked();
         mNoAnimActivities.clear();
 
diff --git a/services/core/java/com/android/server/am/AppErrors.java b/services/core/java/com/android/server/am/AppErrors.java
index cb37999..1f9a8c1 100644
--- a/services/core/java/com/android/server/am/AppErrors.java
+++ b/services/core/java/com/android/server/am/AppErrors.java
@@ -257,7 +257,8 @@ class AppErrors {
         }
         if (app.pid > 0 && app.pid != MY_PID) {
             handleAppCrashLocked(app, "user-terminated" /*reason*/,
-                    null /*shortMsg*/, null /*longMsg*/, null /*stackTrace*/, null /*data*/);
+                    null /*shortMsg*/, null /*longMsg*/, null /*stackTrace*/, null /*data*/,
+                    AppStateBroadcaster.STOP_REASON_ANR);
             app.kill("user request after error", true);
         }
     }
@@ -454,6 +455,10 @@ class AppErrors {
                     if (r != null) {
                         if (!makeAppCrashingLocked(r, shortMsg, longMsg, stackTrace, null))
                         {
+                            if(AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+                                AppStateBroadcaster.sendApplicationStop(mContext, r.info.packageName,
+                                            r.pid, AppStateBroadcaster.STOP_REASON_CRASH);
+                            }
                             r.kill("crash", true);
                         }
                     } else {
@@ -479,7 +484,7 @@ class AppErrors {
         startAppProblemLocked(app);
         app.stopFreezingAllLocked();
         return handleAppCrashLocked(app, "force-crash" /*reason*/, shortMsg, longMsg, stackTrace,
-                data);
+                data, AppStateBroadcaster.STOP_REASON_CRASH);
     }
 
     void startAppProblemLocked(ProcessRecord app) {
@@ -572,7 +577,8 @@ class AppErrors {
     }
 
     boolean handleAppCrashLocked(ProcessRecord app, String reason,
-            String shortMsg, String longMsg, String stackTrace, AppErrorDialog.Data data) {
+            String shortMsg, String longMsg, String stackTrace, AppErrorDialog.Data data,
+            int stopReason) {
         long now = SystemClock.uptimeMillis();
 
         Long crashTime;
@@ -609,12 +615,20 @@ class AppErrors {
                 // Don't let services in this process be restarted and potentially
                 // annoy the user repeatedly.  Unless it is persistent, since those
                 // processes run critical code.
+                if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+                    AppStateBroadcaster.sendApplicationStop(mContext, app.info.packageName,
+                            app.pid, stopReason);
+                }
                 mService.removeProcessLocked(app, false, false, "crash");
                 mService.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                 return false;
             }
             mService.mStackSupervisor.resumeFocusedStackTopActivityLocked();
         } else {
+            if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)) {
+                 AppStateBroadcaster.sendApplicationStop(mContext, app.info.packageName,
+                         app.pid, stopReason);
+            }
             TaskRecord affectedTask =
                     mService.mStackSupervisor.finishTopRunningActivityLocked(app, reason);
             if (data != null) {
@@ -729,6 +743,10 @@ class AppErrors {
                 int res = mService.mController.appEarlyNotResponding(
                         app.processName, app.pid, annotation);
                 if (res < 0 && app.pid != MY_PID) {
+                    if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+                        AppStateBroadcaster.sendApplicationStop(mContext, app.info.packageName,
+                                app.pid, AppStateBroadcaster.STOP_REASON_ANR);
+                    }
                     app.kill("anr", true);
                 }
             } catch (RemoteException e) {
@@ -851,6 +869,11 @@ class AppErrors {
         mService.addErrorToDropBox("anr", app, app.processName, activity, parent, annotation,
                 cpuInfo, tracesFile, null);
 
+        if (AppStateBroadcaster.isDeviceReportingEnabled(mContext)){
+            AppStateBroadcaster.sendApplicationStop(mContext, app.info.packageName,
+                    app.pid, AppStateBroadcaster.STOP_REASON_ANR);
+        }
+
         if (mService.mController != null) {
             try {
                 // 0 == show dialog, 1 = keep waiting, -1 = kill process immediately
diff --git a/services/core/java/com/android/server/am/AppStateBroadcaster.java b/services/core/java/com/android/server/am/AppStateBroadcaster.java
new file mode 100644
index 0000000..21555dd
--- /dev/null
+++ b/services/core/java/com/android/server/am/AppStateBroadcaster.java
@@ -0,0 +1,383 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer in the documentation and/or other materials provided
+ * with the distribution.
+ * * Neither the name of The Linux Foundation nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ **/
+
+package com.android.server.am;
+
+import com.android.internal.app.ProcessMap;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Process;
+import android.os.PersistableBundle;
+import android.os.SystemProperties;
+import android.util.ArrayMap;
+import android.util.Slog;
+import android.telephony.CarrierConfigManager;
+import android.util.SparseArray;
+
+import java.lang.Math;
+import java.lang.Throwable;
+import java.util.HashMap;
+import java.util.HashSet;
+
+/**
+ * Broadcasts diagandroid.app.ApplicationState intents
+ */
+class AppStateBroadcaster {
+
+    private static final boolean DEBUG = true;
+    private static final String LOG_TAG = "AppStateBroadcaster";
+    private static final String KEY_DEVICE_REPORTING_BOOL =
+           "config_enable_device_reporting";
+    public static final String KEY_DEVICE_REPORTING_REGIONAL = "310260";
+
+    private static volatile boolean sBroadcastEnabled = false;
+    private static String sLastFocusAppName = null;
+    private static String sAppLosingFocus = null;
+
+/**
+ * Enables broadcast of intents.
+ */
+    public static void enableIntentBroadcast(Context context,ProcessMap<ProcessRecord> processes) {
+        sBroadcastEnabled = true;
+        sLastFocusAppName = null;
+        populateRunningProcesses(context,processes);
+    }
+
+    public static boolean getEnableIntentBroadcast() {
+        return sBroadcastEnabled;
+    }
+
+/**
+ * Disables broadcast of intents.
+ */
+    public static void disableIntentBroadcast() {
+        sBroadcastEnabled = false;
+        sLastFocusAppName = null;
+        synchronized(sKnownRunningPackages) {
+            sKnownRunningPackages.clear();
+        }
+    }
+
+/**
+ * Broadcasts an intent with the "ApplicationState" extra set to "START"
+ * if the application package is not already in our running list
+ */
+    public static void sendApplicationStart( Context context, String packageName, int processId ) {
+        if ( sBroadcastEnabled && shouldReportApp( packageName ) ) {
+            packageRunning( context, packageName, processId );
+        }
+    }
+
+/**
+ * Broadcasts an intent with the "ApplicationState" extra set to "FOCUS_GAIN"
+ */
+    public static void sendApplicationFocusGain( Context context, String packageName ) {
+        if (DEBUG) {
+            Throwable dummy = new Throwable();
+            Slog.d(LOG_TAG, "sendApplicationFocusGain(" + packageName + ") called from " +
+                    dummy.getStackTrace()[1].toString());
+        }
+        if ( sBroadcastEnabled && shouldReportApp( packageName ) && isKnownRunning(packageName) ) {
+            if ( sLastFocusAppName == null || !packageName.equals(sLastFocusAppName) ) {
+                if ( sLastFocusAppName != null ) {
+                    if (DEBUG)
+                        Slog.d(LOG_TAG, "sendApplicationFocusGain sent APP_STATE_FOCUS_LOSS for " +
+                                sLastFocusAppName );
+                    broadcastAppState(context,sLastFocusAppName,APP_STATE_FOCUS_LOSS);
+                }
+                broadcastAppState( context, packageName, APP_STATE_FOCUS_GAIN );
+                if (DEBUG)
+                    Slog.d(LOG_TAG, "sendApplicationFocusGain sent APP_STATE_FOCUS_GAIN for " +
+                            packageName +
+                            ", old focus package was " +
+                            sLastFocusAppName );
+                sLastFocusAppName = packageName;
+            }
+        }
+    }
+
+/**
+ * Broadcasts an intent with the "ApplicationState" extra set to "FOCUS_LOSS"
+ */
+    public static void sendApplicationFocusLoss( Context context, String packageName ) {
+        if (DEBUG) {
+            Throwable dummy = new Throwable();
+            Slog.d(LOG_TAG, "sendApplicationFocusLoss(" +
+                   packageName +
+                   ") called from " +
+                   dummy.getStackTrace()[1].toString());
+        }
+        if ( sBroadcastEnabled && shouldReportApp( packageName ) && isKnownRunning(packageName) ) {
+            broadcastAppState(context, packageName, APP_STATE_FOCUS_LOSS);
+            if (packageName.equals(sLastFocusAppName)) {
+                sLastFocusAppName = null;
+            } else if (DEBUG) {
+                Slog.d(LOG_TAG, "sendApplicationFocusLoss - " +
+                        packageName +
+                        " does not match last focus package " +
+                        sLastFocusAppName );
+            }
+            if (DEBUG)
+                Slog.d(LOG_TAG, "sendApplicationFocusLoss sent APP_STATE_FOCUS_LOSS for " +
+                        packageName);
+        }
+    }
+
+    // legal values for ApplicationStop stopReason parameter
+    public static final int STOP_REASON_NORMAL_SYSTEM_HALT = 0;
+    public static final int STOP_REASON_USER_HALT = 1;
+    public static final int STOP_REASON_ANR = 2;
+    public static final int STOP_REASON_CRASH = 3;
+
+/**
+ * Broadcasts an intent with the "ApplicationState" extra set to "Exited" and
+ * the "ApplicationTermReason" extra containing the value corresponding to stopReason
+ * if the application package is in our running list
+ */
+    public static void sendApplicationStop( Context context, String packageName,
+            int processId, int stopReason) {
+        if (DEBUG) {
+            Throwable dummy = new Throwable();
+            Slog.d(LOG_TAG, "sendApplicationStop(" +
+                    packageName + "," +
+                    processId + "," +
+                    stopReason + ") called from " +
+                    dummy.getStackTrace()[1].toString());
+        }
+
+        if ( sBroadcastEnabled && shouldReportApp( packageName ) ) {
+            if ( stopReason >= 0 && stopReason < APP_TERM_REASONS.length ) {
+                packageStopped( context, packageName, processId, stopReason );
+            }
+        }
+    }
+
+    // Intent name
+    private static final String INTENT_NAME = "diagandroid.app.ApplicationState";
+
+    // Permission name
+    private static final String PERMISSION_NAME = "diagandroid.app.receiveDetailedApplicationState";
+
+    // ApplicationPackageName extra:
+    private static final String EXTRA_APP_PACKAGE_NAME = "ApplicationPackageName";
+
+    // ApplicationState extra:
+    private static final String EXTRA_APP_STATE = "ApplicationState";
+    // ApplicationState values
+    private static final String    APP_STATE_EXITED = "EXITED";
+    private static final String APP_STATE_START = "START";
+    private static final String APP_STATE_FOCUS_GAIN = "FOCUS_GAIN";
+    private static final String APP_STATE_FOCUS_LOSS = "FOCUS_LOSS";
+
+    // ApplicationTermReason extra:
+    private static final String EXTRA_APP_TERM_REASON = "ApplicationTermReason";
+    // values
+    private static final String APP_TERM_REASON_SYSTEM_HALT = "NORMAL_SYSTEM_HALT";
+    private static final String APP_TERM_REASON_USER_HALT = "USER_HALTED";
+    private static final String APP_TERM_REASON_ANR = "ANR";
+    private static final String APP_TERM_REASON_CRASH = "CRASH";
+    // not private for access by ApplicationState
+    static final String[] APP_TERM_REASONS = {
+        APP_TERM_REASON_SYSTEM_HALT,
+        APP_TERM_REASON_USER_HALT,
+        APP_TERM_REASON_ANR,
+        APP_TERM_REASON_CRASH };
+
+    // Do not report if no package name availabe to track
+    private static boolean shouldReportApp( String packageName ) {
+        return packageName != null;
+    }
+
+    private static String stripPackageName(String packageName) {
+        String result = packageName;
+        int packageEnd = packageName.indexOf(':');
+        if ( packageEnd != -1 ) {
+            result = packageName.substring(0,packageEnd);
+        }
+        return result;
+    }
+
+    private static void broadcastAppState( Context context, String packageName, String appState ) {
+       if ( context != null &&
+                packageName != null &&
+                appState != null &&
+                appState != APP_STATE_EXITED ) {
+            Intent appStateIntent = new Intent( INTENT_NAME );
+            appStateIntent.putExtra( EXTRA_APP_PACKAGE_NAME, stripPackageName(packageName) );
+            appStateIntent.putExtra( EXTRA_APP_STATE, appState );
+            context.sendBroadcastAsUser( appStateIntent, Process.myUserHandle(), PERMISSION_NAME );
+        }
+    }
+
+    private static void broadcastAppExit( Context context, String packageName, String termReason ) {
+        if ( context != null &&
+                packageName != null &&
+                termReason != null ) {
+            Intent appStateIntent = new Intent( INTENT_NAME );
+            appStateIntent.putExtra( EXTRA_APP_PACKAGE_NAME, stripPackageName(packageName) );
+            appStateIntent.putExtra( EXTRA_APP_STATE, APP_STATE_EXITED );
+            appStateIntent.putExtra( EXTRA_APP_TERM_REASON, termReason );
+            context.sendBroadcastAsUser( appStateIntent, Process.myUserHandle(), PERMISSION_NAME );
+        }
+    }
+
+/**
+ * stores package names ( root package name + ones with with ':') associated with root package name
+ */
+    private static final HashMap<String,ApplicationState> sKnownRunningPackages =
+            new HashMap<String,ApplicationState>();
+
+/**
+ * tells us whether the package is known to be running
+ **/
+    private static boolean isKnownRunning(String packageName) {
+        boolean result = false;
+        synchronized (sKnownRunningPackages) {
+            result = sKnownRunningPackages.containsKey(stripPackageName(packageName));
+        }
+        return result;
+    }
+
+/**
+ * populates sKnownRunningPackages at startup
+ **/
+    private static void populateRunningProcesses(Context context,ProcessMap<ProcessRecord> processes) {
+        for ( SparseArray<ProcessRecord> processRecords : processes.getMap().values() ) {
+            for ( int index = 0; index < processRecords.size(); ++index ) {
+                ProcessRecord process = processRecords.valueAt( index );
+                sendApplicationStart(context, process.info.packageName, process.pid );
+            }
+        }
+    }
+
+/**
+ * adds packageName to sKnownRunningPackages,
+ * if it was not previously present, sends the intent containing APP_STATE_START
+ */
+    private static void packageRunning( Context context, String packageName, int processId ) {
+        synchronized(sKnownRunningPackages) {
+            String rootPackageName = stripPackageName(packageName);
+            if (DEBUG)
+                   Slog.d(LOG_TAG, "packageRunning for " + rootPackageName +
+                          " with processId " + processId + " packageName " +  packageName);
+            ApplicationState appState= sKnownRunningPackages.get( rootPackageName );
+            if ( appState == null ) {
+                // create and add
+                appState = new ApplicationState();
+                sKnownRunningPackages.put( rootPackageName, appState );
+                broadcastAppState( context, packageName, APP_STATE_START );
+                if (DEBUG) Slog.d(LOG_TAG,"packageRunning sent APP_STATE_START for " +  packageName);
+            }
+            appState.addProcess(processId);
+        }
+    }
+
+/**
+ * finds ApplicationState for packageName
+ * removes processId and sets stopReason on ApplicationState
+ * if ApplicationState reports empty (no processes)
+ *   if packageName is sLastFocusAppName send focus loss intent and cleats sLastFocusAppName
+ *   remove packageName from sKnownRunningPackages
+ *   send exit intent for packageName
+ */
+    private static void packageStopped( Context context, String packageName, int processId,
+           int stopReason ) {
+        synchronized(sKnownRunningPackages) {
+            String rootPackageName = stripPackageName(packageName);
+            if (DEBUG) Slog.d(LOG_TAG,
+                    new StringBuilder( "packageStopped for " )
+                            .append(rootPackageName)
+                            .append(" with processId=")
+                            .append(processId)
+                            .append(" packageName=")
+                            .append(packageName)
+                            .append( " stopReason=")
+                            .append(stopReason)
+                            .toString() );
+            ApplicationState appState = sKnownRunningPackages.get( rootPackageName );
+            if ( appState != null ) {
+                if (DEBUG) Slog.d(LOG_TAG,"Removing process " + processId +
+                        ", packageName " + packageName + " from rootPackage " + rootPackageName);
+                if ( appState.removeProcess( processId, stopReason ) ) {
+                    if (DEBUG) Slog.d(LOG_TAG,"Removing " + rootPackageName +
+                            " from running packages" );
+                   if ( sLastFocusAppName != null &&
+                         packageName.equals( sLastFocusAppName ) ) {
+                        sendApplicationFocusLoss( context, packageName );
+                        sLastFocusAppName = null;
+                    }
+                    sKnownRunningPackages.remove( rootPackageName );
+                    broadcastAppExit( context, rootPackageName, appState.getTermReason() );
+                    if (DEBUG) Slog.d("AppStateBroadcaster",
+                            "sendApplicationStop sent APP_STATE_EXITED for " +  packageName);
+                }
+            }
+        }
+    }
+
+    public static boolean isDeviceReportingEnabled(Context context) {
+         boolean isCarrierSimCard = false;
+         CarrierConfigManager carrierConfigManager =
+                 (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+         if (carrierConfigManager != null) {
+              PersistableBundle carrierConfig = carrierConfigManager.getConfig();
+              if(carrierConfig != null) {
+                  isCarrierSimCard = carrierConfig.getBoolean(KEY_DEVICE_REPORTING_BOOL);
+              }
+         }
+         if (DEBUG)
+             Slog.d("AppStateBroadcaster", "is home Carrier SIM Card? " + isCarrierSimCard);
+         return isCarrierSimCard;
+    }
+}
+
+class ApplicationState {
+    private int mStopReason;
+    private HashSet<Integer>    mProcessIds;
+
+    public ApplicationState() {
+        mStopReason = AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT;
+        mProcessIds = new HashSet<Integer>();
+    }
+
+    public String getTermReason() {
+        return AppStateBroadcaster.APP_TERM_REASONS[ mStopReason ];
+    }
+
+    public void addProcess( int processId ) {
+        mProcessIds.add( Integer.valueOf( processId ) );
+    }
+
+    public boolean removeProcess( int processId, int stopReason ) {
+        mStopReason = Math.max( stopReason, mStopReason );
+        mProcessIds.remove( Integer.valueOf( processId ) );
+        return mProcessIds.isEmpty();
+    }
+};
diff --git a/services/core/java/com/android/server/am/UserController.java b/services/core/java/com/android/server/am/UserController.java
index b685dd3..de43071 100644
--- a/services/core/java/com/android/server/am/UserController.java
+++ b/services/core/java/com/android/server/am/UserController.java
@@ -644,7 +644,7 @@ final class UserController {
 
     private void forceStopUserLocked(int userId, String reason) {
         mService.forceStopPackageLocked(null, -1, false, false, true, false, false,
-                userId, reason);
+                userId, reason, AppStateBroadcaster.STOP_REASON_NORMAL_SYSTEM_HALT);
         Intent intent = new Intent(Intent.ACTION_USER_STOPPED);
         intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
                 | Intent.FLAG_RECEIVER_FOREGROUND);
-- 
1.8.2.1


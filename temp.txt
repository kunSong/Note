Chapter 19

Vocabulary
+ caveats
+ radical
+ Intuitively
+ soundness
+ sake
+ arguably
+ prominent

+ null

+ 类型参数化允许您编写通用类和特征。例如，Set泛型Set[T]。其实例化结果是Set[String]和Set[Int]等，但它必须是something。不同于Java，它允许原始类型，Scala要求您指定类型参数。差异是parameterization types的继承关系，例如Set[String]是否是Set[AnyRef]的子类型。

+ 本章包含三部分。第一部分为开发纯粹functional queue的数据结构。第二部分开发隐藏此结构内部表示细节的技术。最后一部分解释了类型参数的差异以及它与信息隐藏的相互作用。

19.1

+ functional queue是一个具有以下功能的数据结构。

+ 不像mutable queue，functional queue是不会改变其内容来append的，而是返回一个包含新元素的新queue。本章的目的是为了来创建一个名叫Queue的类，能像如下工作。

+ 如果是mutable queue，上述代码q和q1的元素都会变成1234，但是过是functional queue只有q1会是1234，而q还是原来的。

+ functional queue和List有点像，他们都是永久持有对象的，就是说在修改和扩展之后旧版本对象仍然是可以用的。这样才能实现head和tail的功能，但是List是用cons`::`在头部加入元素，而queue是用append在尾部加入元素。

+ 效率如何？理想情况下, functional queue(immutable)的开销不应该比imperative(mutable)
更高。也就是说, 所有三操作head，tail和append都应在恒定时间内操作。

+ 一个简单方法来实现functional queue，就是使用list来作为元素类型。使用list的head，tail和`:::`。

+ 但是append方法不是恒定的，取决于list中的元素数量。所以使用了反转顺序来添加元素实现append。

+ 现在append是恒定了，但是head和tail不是了，需要花费元素数量的时间量。

+ 看到这两个例子都不能很好的权衡这三个方法，所以我们可以用两个list，leading和tailing，来表达队列。leading包含前段元素，而trailing包含了反向排列的后段元素。队列在任何时刻的所有内容都可以表示为`leading ::: trailing.reverse`。

+ 想要添加新元素，只要使用::操作符将其添加到trailing，使得append是常量时间。当原始的空队列通过后继的append操作构建起来时，trailing将不断增加，而leading始终是空白的。于是，在对空的leading第一次执行head或者tail操作之前，trailing应该被反转并复制给leading，这个操作称为mirror。

+ 那这个queue的复杂度呢？mirror操作花费的时间大概与队列的元素数量成正比，但仅在leading为空时。如果leading非空，它将直接返回。因为head和tail调用了mirror，所以他们的复杂度与队列长度呈线性关系。实际上，假设leading为空时，mirror才翻转并复制，那么n个元素需要进行n次tail之后才进行复制。这n次tail操作平均分担了mirror操作的时间复杂度，也相当于常量时间了。所以Queue和mutable对象效率是差不多的。

+ 对于这个论据的两个告诫。第一，常数可能不同。第二，论据是在head，tail和append操作频率差不多的情况下。如果头操作比其他两个多，则论据无效，因为需要调用mirror方法重组成本高昂。如果要避免第二个告诫，设计一个functional queue在连续的head操作中，仅有第一次操作需要重组。会在本章末尾得到。

19.2

+ 上面实现的Queue以暴露本不该暴露的实现细节为代价，全局可访问Queue构造器，带有两个列表参数，不能作为直观表达队列的形式。

+ Scala的主构造方法并没有显示定义，可以通过把private修饰符添加在类参数列表的前面把主构造器隐藏起来。

+ 构造器是私有的，它只能被类本身及伴生对象访问。Queue是public，类型是可以访问的。

+ null

+ null

+ 我们可以添加可以用初始元素序列创建队列的工厂方法。定义与类同名的Queue对象及apply方法。

+ 通过放在一个文件中的伴随对象Object Queue来构造class Queue。

+ `Queue(1,2,3)`扩展为`Queue.apply(1,2,3)`，因为Queue用对象代替了函数，scala没有全局可见的方法，方法都是在object或class中。

+ 使用私有类的方法可以更彻底的把类本身隐藏掉，仅提供能够暴露类公共接口的特质。代码中定义了特质Queue，声明了方法head、tail和append。 这三个方法都实现在子类QueueImpl中，而它本身是对象Queue的内部类。这个方案暴露给客户的信息与前面相同，但使用了不同的技术。代之以逐个隐藏构造器与方法，这个版本隐藏全部实现类。

19.3

+ 因为Queue是一个trait不是类型type，因为他带了type parameter`[T]`所以不是type。所以不能创建变量如下编译。

+ trait Queue指明type parameter例如Queue[Int]，Queue[String]，就可以编译了。

+ Queue是一个trait，Queue[String]是一个type。Queue被叫做type constructure类型构造器，可以明确指定一种类型参数type parameter。

+ 你可以叫Queue[T]是泛型，Queue[Int]就是特殊类型的Queue。

+ S是T的子类型，那么Queue[S]是Queue[T]的子类型。那么Queue叫做是协变的。例如Queue[AnyRef]作为入参类型，可以传入Queue[String]为类型的入参。

+ 默认的Queue[T]就是非变。所以Queue[String]不能用做Queue[AnyRef]，但是通过改变如下类型前加一个`+`来控制是协变的。

+ 通过前缀`+`就可以协变，Queue[String]是Queue[AnyRef]的子类型。

+ 除了`+`还有`-`，这是逆变的。

+ 如果T是S的子类型，这就暗示了Queue[S]是Queue[T]的。协变，逆变，不变被统称为参数变化。`+``-`被放在参数旁边被叫做变化解释。

+ 在纯粹的函数式世界里，许多类型是自然变化的。但是, 一旦引入可变数据, 情况就会发生变化。要了解原因, 请考虑如下例子。

+ 上述19.5声明为非变的。为了论证起见, 假定Cell已被声明为协变。被声明为`Class[+T]`。很快会解释，你可能构建下列疑难语句。

+ 解释上述每一行，前三句看起来不错，最后一句将一个integer 1赋值给string s，这显然是对类型健全的侵犯。

+ 运行时的错误归因于使用了协变。Cell[String]不是Cell[Any]，因为你可以对Cell[Any]做的不能对Cell[String]做。

+ 事实上把协变版本的Cell给到编译器会发生编译错误。

+ 可以用Java的arrays来做比较，arrays和上述Cell很像，只是arrays多几个元素。arrays可以被看做是协变的。可以用arrays来模拟上述Cell的代码。

+ 可以编译通过但是执行时会报错ArrayStore exception，因为a2[0]被赋值了Integer。

+ 因为Java在在运行时存储array中的元素的，当每次更新元素的时候会检查对应的类型。如果不是那个类型实例就会抛出ArrayStore异常。

+ 为什么Java会采用如此设计，看似不安全并且昂贵的。他们想用一种简单的方法来处理数组。例如, 他们希望能够编写一个方法来对数组中的所有元素进行排序, 使用类似下面的签名, 它接受了一个对象数组。

+ 协变是需要的，这样任意引用类型的数组能传入这个方法。当然，由于Java泛型的到来，这个排序方法可以用类型参数type parameter来写，因此不需要协变。出于兼容性考虑，一直沿用到现在。

+ Scala试图比Java更纯净而不是把arrays当做协变处理。前两行转为scala会看到如下。

+ 这里Scala把arrays当做了非变的，所以不能把Array[String]被考虑成Array[Any]。但是有时需要和Java中的旧方法进行交互，就用了对象数组来模拟泛型数组。比如你想调用之前描述的排序方法用Strings作为入参。为了实现可能，Scala允许你把Array[T]强转为Array[Any]，Any是T的父类。

+ 在编译时, 强制转换始终是合法的, 并且它总是在run-time上成功, 因为JVM的底层run-time模型将数组视为协变。但你可能还会得到ArrayStore exception, 就像你在java中。

19.4

+ 目前，违反类型健全涉及到可被赋值字段或array元素。纯粹的函数式实现Queue看起来是很好的协变候选。但是, 下面的示例显示, 即使没有reassignable字段, 也可以有不健全的情况。

+ 假设在19.4中定义的Queue是协变的。那定义一个子类型指明元素类型为Int，然后重载append方法。

+ 在调用父类append前计算传入x的根号值。

+ 这两行的第一行是有效的，因为StrangeIntQueue是Queue[Int]的子类，假设Queue是协变的，Queue[Int]是Queue[Any]的子类。第二行也是有效的因为你可以在Queue[Any]上append String。然而把这两个放在一起，在string上起到平方根的作用是没有意义的。

+ 显然, 不只是可变字段使协变类型不健全。结果表明, 当泛型参数类型以方法参数的类型显示时, 该类型参数中的包含类或特征可能不具有协变。对于Queue, append方法违反了此条件:

+ reassignable字段是特例, 它不允许用`+` 批注的类型参数作为方法参数类型。18.2提到, reassignable字段`var x: T`, 在 scala中作为getter方法处理`def x: T`和setter方法`def x_= (y: T)`。您可以看到, setter方法具有字段类型T的参数。因此, 该类型可能不是协变的。

+ the fast track

19.5

+ 回到Queue类，你看到Queue[T]不能协变，因为T是作为append方法的类型参数type parameter。

+ 有办法来摆脱，你可以泛化append方法通过多态，在type parameter上使用a lower bound。如下。

+ 这新的定义是给append方法一个类型参数type parameter U，语法是`U >: T`。定义T是U的下界。结果，U是T的父类。那现在用U代替了T作为append的入参类型。返回值也从Queue[T]变成了Queue[U]。

+ 例如，假设现在有两个Fruit类的子类，Apple和Orange。通过新的Queue的定义，可以在Queue[Apple]上append Orange，结果是Queue[Fruit]。

+ 修正定义了append的类型是正确的。如果T是比期望更加具体的类型比如Apple代替Fruit，调用append始终可以工作，因为U(Fruit)是T(Apple)的父类。

+ 新定义的append好，因为他更加通用化。新定义允许你append类型为T的Queue的元素的父类型U的任意元素。结果是Queue[U]。结合queue的协变，可以很自然的构建不同类型元素的queue。

+ variance annotations(即非变，协变和逆变)可以和lower bounds完美结合。他是一个很好的类型驱动设计。

+ Scala会倾向于declaration-site variance，因为可以在编译的时候就检查，不至于像use-site variance在使用时就发现某个方法不适用。

19.6

+ 这里讲下逆变。

+ 这里OutputChannel被定义为逆变T。所以OutputChannel[AnyRefs]是OutputChannel[String]的子类。是有意义的，考虑OutputChannel[String]的操作是写一个字符串。那OutputChannel[AnyRefs]可以来代替OutputChannel[String]来完成操作，但还相反OutputChannel[String]不能代替OutputChannel[AnyRefs]，因为OutputChannel[String]都是string的操作。

+ 当T是U的子类型，需要U的地方可以安全的替换T。这是Liskvo替换原则。

+ 有时协变和逆变是混合在相同类型的。一个突出的例子是Scala的function traits。例如，当你写一个function value `A => B`会扩展为Function1[A, B]。A是逆变的，B是协变的。

+ 解释下列代码，入参为Book，返回的是AnyRef，最后调用的方法返回的是String。

+ null

+ 最后一行的结果是String是AnyRef的子类，因为function是协变的，所以可以这样。

+ 解释最后一行代码。

+ getTitle的入参是Publication，而printBookList的入参类型是Book。这是工作的因为Function1定义的是逆变的。Book具有Publication的所有功能。

+ 解释下图协变和逆变的继承关系。左边是逆变，右边是协变的。

19.7

+ 到目前为止，Queue类仍有一些问题。如果head被一遍遍的调用很多次，而leading列表为空，那么mirror操作可能会重复的把trailing复制到leading列表。

+ 可以将leading和trailing指定为可以重新复制的变量，而mirror从trailing反向复制到leading的操作是在当前队列上的副作用，而不再返回新的队列。通过将leading和trailing用private[this]修饰，声明为对象私有变量，使得这种副作用纯粹是Queue操作的内部实现，从而使它对于Queue的客户不可见。

+ null

+ null

+ 被定义在同一个对象内访问对象私有变量不会引起与变化型有关的问题。Scala的变化型检查规则包含了关于对象私有定义的特例。当检查到带有`+``-`号的类型参数只出现在具有相同变化型分类的位置上时，这种定义将被忽略。如果把this去掉会报错如下。

19.8

+ 在这重新看下16.1，我们为list写了merge sort函数，第一个入参为比较函数，第二个入参是要比较list。另一种方法是采用混入mix-in Ordered trait，实现Ordered的抽象compare方法，你可以使客户端通过大于，小于，小于等于和大于等于来比较类实例。

+ 当你传入新的sort function混入了Ordered的类型需要用upper bound。upper bound和lower bound类似。上界使用了`<:`语法，意思是T有一个上界Ordered[T]。这意味着传入orderedMergeSort的list的元素类型必须是Ordered的子类型。你可以传入List[Person]给orderedMergeSort，因为Person混入了Ordered。

+ 但是你不能来用orderedMergeSort来排序Int类型的类，因为Int不是Ordered[Int]的子类型。

Chapter 20

Vocabulary
+ resembles
+ subtle
+ analogous
+ analogy
+ exemplifies

+  抽象class或者trait的成员没有完成实现定义，抽象成员可以在子类中实现。Scala中除了抽象方法，还有抽象字段和抽象类型作为class或trait的成员

+ 讨论内容看下。

20.1

+ 如下定义了抽象成员。

+ 具体抽象类的实现。

+ type T定义为type String的别名。其他的进行了实现和初始化。

+ null

20.2

+ 一个抽象类型abstract type永远是一个class或trait的成员。

+ 定义非抽象的type成员，可以给类型起新的名字或别名。例如，在定义的类中出现T，那就是代表String类型。

+ 第一个目的是为了简洁，更容易检查代码。第二个目的是父类定义抽象type，子类可以来继承实现。

20.3

+ 抽象val的定义如下。

+ 提供了名字和类型，但没有值。值是在子类中实现的。

+ 你可以来使用这个抽象的val当你不知道准确值的时候，但是你要知道这是一个不可改变的变量在每个实例类中。

+ 抽象val定义类似于一个没有括号的的抽象方法定义，如下。

+ 调用者可以通过`obj.initial`来调用val和method。如果initial是abstract val，那保证调用者每次得到的引用值是相同的。而如果是abstract method，那具体子类实现的方法，得到的值会不同。

+ abstract method可以被子类用method和val override，但是abstract val只能是val。

20.4

+ 像abstract val一样，var也定义了名字和类型。

+ 在18.2节你看到定以vars会配备getter和setter。同理定以abstract vars也会隐式定以abstract getter和abstract setter方法。如下。这里不会有可赋值字段定义会在子类中具体实现abstract var。

20.5

+ abstract vals有时扮演了一个类似父类构造参数，父类中没有的在子类中提供具体的。特别重要的是traits，因为trait没有构造方法你可以传构造参数给他。所以可以用abstract val来在子类中实现。下面是Chapter 6的重新构造的Rational。

+ Chapter 6的Rational类有两个参数一个是分子一个是分母。RationalTrait用两个abstract val来定义。如果要实例化一个trait实例，需要实现absract val的定义。

+ new关键字来实例化一个RationalTrait，后面大括号中是类体，这个实例化了一个匿名类mix-in了一个trait。类似于`new Rational(1, 2)`，但是这样类比不是很好，考虑到如果写成如下表达式就会有微妙的不同在初始化的先后顺序。

+ expr1和expr2在类Rational初始化前就已经被评估了，所以他们是Rational初始化时可以访问的。但是对于trait来说就是相反的。

+ expr1和expr2的评估是匿名类初始化的一部分，而匿名类初始化是在RationalTrait初始化之后。所以这两个abstract val在RationalTrait初始化的时候是访问不到的，如果是Int型会给一个默认的0。因为上面代码这两个值没有用到，所以没关系。但是看下面的代码这两个值被用到了，就会有问题。当new的时候会报错。

+ null

+ 因为在RationalTrait初始化的时候始终还是0，所以报了require的错。

+ 所以证明了类构造参数和abstract val的初始化顺序有区别的。前者在类构造前就初始化好了，后在是在子类中实现，需要在父类初始化后在被评估的。

+ 那解决这个问题，scala提供了两种方法，pre-initialized和lazy vals。

Pre-initialized fields

+ 在父类调用前就初始化子类字段。如下。

+ Pre-initialized fields不仅限于匿名类。还可以用在对象或命名的子类中。在20.6和20.7中你可以看到Pre-initialized的部分是在extends关键字后的。20.7中的RationalClass类展现了一个通用的模式，类参数如何可以被父trait初始化时访问到的。

+ 因为Pre-initialized是在父类构造方法调用前初始化的，他们的初始化者是不能引用到要被构建的对象的。如下this.numerArg。

+ null

Lazy vals

+ 除了前面介绍的预先初始化成员值外，你还是让系统自行决定何时初始化成员的初始值，这是通过在val定义前面添加 lazy，也是说直到你第一次需要引用该成员时，系统才会去初始化，否则该成员就不初始化。

+ 正如你所看到的，当引用Demo对象时，它的成员x也会初始化，初始化x伴随着初始化Demo的过程。然后，如果我们在val x前添加lazy，情况就有所不同了。

+ 在使用lazy之后，初始化Demo时，不会初始化x，只有在引用到Demo.x该初始化代码才会执行。

+ 这有点类似定义了一个无参数的方法，但和def不同的是，lazy变量初始化代码只会执行一次。事实上，第一次评估后，lazy变量的值就被存储了，等后续同样的val被调用的时再使用。

+ 可以看到例如Demo的对象本身也像一个lazy变量，也是在第一次引用时才会初始化。实际上一个object定义可以看成是使用了lazy val定义一个匿名类实例的简化方式。

+ 使用lazy val，修改之前的RationalTrait，在这个新的Trait定义中，所有的类成员变量的实现(非抽象成员)都使用lazy来修饰。同时把require移动到g里面，这样所有的lazy val初始化代码都移动到val定义的右边。我们不再需要预先初始化成员变量。

+ 分析一下这段代码中命令行的执行顺序。
  - 首先，创建了一个新的LazyRationalTrait的实例，执行LazyRationalTrait的初始化代码，这部分代码为空，LazyRationalTrait所有成员变量都没有初始化。
  - 其次，该Trait的匿名子类的主构造函数被执行，这部分初始化numberArg和denomArg 为2和4.
  - 接下来，命令行需要调用该实例的toString方法来显示该实例的值。
  - 接下来，toString需要访问成员number这是第一次访问该成员，因此lazy val 初始化代码被执行。初始化代码调用私有成员g，因此需要计算g的值，用到之前定义过的numberArg和denomArg。
  - 接下来toString需要访问成员denom这是第一次访问该成员，因此lazy val初始化代码被执行。初始化代码调用私有成员g，因此需要计算g的值，因为g已经计算过，无需再计算。
  - 最后，toString的结果1/2构造出来并显示。

+ 在这个例子中，我们在写代码时，g定义在number和denom的后面，然而，由于这三个变量都是使用lazy来定义的，因此它们在代码中出现的顺序并不重要，因为值会按需求初始化。

+ null

+ null

20.6

+ Type T的用法，这是声明一个抽象类型，本篇介绍这种声明的意义和用途。和其它类型的抽象类型一样，抽象类型定义也是定义了一个占位符类型，其具体定义由其子类声明。不同的子类可以定义不同T的具体类型。 

+ 一个例子，假定你需要为动物的饮食习性建模， 你可能会定义如下的数据结构。

+ 怎么会出错呢，这是因为类Cow中的eat不能重载其父类，这是因为参数类型不一致，Animal中food类型为Food，而Cow中类型为Grass。

+ 仅管有人会说Grass是Food的子类，编译器没有必要这么严格。但是如果编译器允许这种情况存在，那么很快就出现新问题了。假定前面的编译没有问题，我们在定义一个Fish类。

+ 问题来了，我们给牛喂了鱼。如果前面的Cow可以编译通过的话，这段代码也是合法的，但结果却显然不对，因此编译器编译不通过Cow是有道理的。

+ 对于这个问题，我们可以通过抽象类型来解决，哪种动物吃哪种食物由动物决定。

+ 当定义新的Animal子类时，动物只能吃合适的食物，而Animal类本身不能决定那种食物合适，因此我们使用抽象类型定义。但这个抽象类型有类型上界限制，表示Animal子类中使用的SuitableFood必须是Food的子类。我们重新定义Cow如下。

+ 如果再给牛喂鱼会得到类型不match错误。



